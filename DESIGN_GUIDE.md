# The cimpl Design Guide

This document captures the design philosophy, key learnings, and best practices for using `cimpl` to create FFI bindings.

## The Three-Stage Pipeline

The core insight of `cimpl` is a three-stage pipeline for creating language bindings:

```
┌─────────────────┐
│  Stage 1: Rust  │  ← Safe, using cimpl utilities
│   (Developer)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Stage 2: C API │  ← Universal, generated by cbindgen
│   (cbindgen)    │  ← This is the "waist" - keep it thin!
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Stage 3: Target │  ← Idiomatic, AI-generated
│    Language     │  ← Python, JavaScript, Lua, etc.
│   (AI/Codegen)  │
└─────────────────┘
```

### Why This Works

1. **Stage 1 (Rust)**: You get Rust's safety guarantees while using `cimpl`'s utilities
2. **Stage 2 (C API)**: Provides a stable, universal interface that never changes
3. **Stage 3 (Target)**: Can be regenerated, adapted, or swapped without touching Rust

**Key Insight**: The C API is the "waist" - keep it simple and stable. Complexity goes in Rust (safe), idioms go in the target language.

## Design Principles

### 1. Standard C Conventions

Follow established C error patterns that developers expect:

```c
// ✅ Good: Standard patterns
Uuid* uuid = uuid_parse(str);
if (uuid == NULL) {  // NULL indicates error
    int code = uuid_error_code();
    char* msg = uuid_last_error();
    // Handle error
}

int result = some_operation();
if (result == -1) {  // -1 indicates error
    // Handle error
}

// ❌ Bad: Custom conventions
Uuid* uuid = uuid_parse(str, &error_code);  // Out parameters
if (uuid && error_code == 0) { ... }        // Confusing
```

**Why**: Standard conventions make the API predictable and AI-friendly.

### 2. Error Handling Strategy

**Separate error indication from error details:**

```rust
// Return value indicates success/failure
#[no_mangle]
pub extern "C" fn uuid_parse(s: *const c_char) -> *mut Uuid {
    let s_str = cstr_or_return_null!(s);  // NULL on error
    let uuid = ok_or_return_null_with_table!(
        Uuid::from_str(&s_str), 
        UUID_ERROR_TABLE
    );
    box_tracked!(uuid)
}

// Separate error retrieval functions
#[no_mangle]
pub extern "C" fn uuid_error_code() -> i32 {
    Error::last_code() as i32
}

#[no_mangle]
pub extern "C" fn uuid_last_error() -> *mut c_char {
    match Error::last_message() {
        Some(msg) => to_c_string(msg),
        None => std::ptr::null_mut(),
    }
}
```

**Error Message Format**: `"ErrorName: details"`
- Makes it easy to parse programmatically
- AI can extract the error type name
- Human-readable details follow

### 3. Universal Memory Management

**One free function for everything:**

```rust
// This is exported by cimpl itself
#[no_mangle]
pub extern "C" fn cimpl_free(ptr: *mut std::ffi::c_void) -> i32 {
    if ptr.is_null() { return 0; }
    match get_registry().free(ptr as usize) {
        Ok(_) => 0,
        Err(e) => {
            e.set_last();
            -1
        }
    }
}
```

**Why this works**:
- Rust tracks the type and cleanup function
- C doesn't need type-specific free functions
- AI can generate simple cleanup code
- Prevents `free()` vs `uuid_free()` vs `string_free()` confusion

### 4. Pointer Registry Architecture

**Don't force wrappers on users:**

```rust
// ✅ Good: User chooses the wrapper
box_tracked!(uuid)           // Box<Uuid>
arc_tracked!(data)           // Arc<Data>
arc_mutex_tracked!(shared)   // Arc<Mutex<Shared>>

// ❌ Bad: Forced wrapper
// Every handle forced to be Arc<Mutex<Box<dyn Any>>>
```

**How it works**:
- Registry stores `(pointer_address, TypeId, CleanupFn)`
- `CleanupFn` is `Box<dyn FnMut() + Send>`
- Enables type validation without dictating allocation strategy

### 5. External Crate Wrapping

**Use external types directly when possible:**

```rust
// ✅ Good: Direct use (if opaque to cbindgen)
use uuid::Uuid;  // Already opaque to C!

#[no_mangle]
pub extern "C" fn uuid_new_v4() -> *mut Uuid {
    box_tracked!(Uuid::new_v4())
}

// ❌ Bad: Unnecessary wrapper
pub struct MyUuid(uuid::Uuid);  // Extra indirection
```

**When the external type is already opaque to C** (has private fields), you can use it directly. No need for wrapper structs.

### 6. Error Code Ranges

**Reserve ranges for different error categories:**

```rust
// Core cimpl infrastructure errors (0-99)
pub static ERROR_OK: i32 = 0;
pub static ERROR_NULL_PARAMETER: i32 = 1;
pub static ERROR_INVALID_HANDLE: i32 = 3;
pub static ERROR_WRONG_HANDLE_TYPE: i32 = 4;

// Library-specific errors (100+)
pub static ERROR_UUID_PARSE_ERROR: i32 = 100;
pub static ERROR_UUID_INVALID_VERSION: i32 = 101;
```

**Why**: Clear separation makes error handling predictable and extensible.

## Language Binding Lessons

### Node.js: Use Modern Tools

**Problem**: `ffi-napi` is unmaintained and incompatible with modern Node.js (18.20.8+, 23+).

**Solution**: Use **Koffi** - actively maintained, works with all Node.js versions.

```javascript
// Koffi is clean and modern
const koffi = require('koffi');
const lib = koffi.load('libmylib.dylib');

const UuidPtr = koffi.pointer(koffi.opaque('Uuid'));
const uuid_new = lib.func('uuid_new_v4', UuidPtr, []);
const cimpl_free = lib.func('cimpl_free', 'int32', [koffi.pointer('void')]);
```

**Key Lesson**: When language-specific FFI tools have issues, the C API is still perfect - just switch tools.

### Python: ctypes Works Great

```python
from ctypes import *

lib = CDLL("./libmylib.dylib")
lib.uuid_new_v4.restype = c_void_p
lib.uuid_to_string.argtypes = [c_void_p]
lib.uuid_to_string.restype = c_char_p
lib.cimpl_free.argtypes = [c_void_p]
```

**Standard library**, widely used, stable.

### Lua: LuaJIT FFI is Excellent

```lua
local ffi = require("ffi")
ffi.cdef[[
    typedef struct Uuid Uuid;
    Uuid* uuid_new_v4(void);
    char* uuid_to_string(Uuid* uuid);
    int32_t cimpl_free(void* ptr);
]]

local lib = ffi.load("./libmylib.dylib")
```

**Built-in**, fast, clean syntax.

## Macro Design Philosophy

### Consistent Naming

All macros follow the pattern: `action_or_return_value`

```rust
// Null checks
ptr_or_return_null!(ptr)
ptr_or_return_neg!(ptr)

// C string conversion
cstr_or_return_null!(cstr)
cstr_or_return_int!(cstr)

// Pointer dereferencing (validates and dereferences)
deref_or_return_null!(ptr, Type)
deref_or_return_zero!(ptr, Type)
deref_mut_or_return_neg!(ptr, Type)

// Result unwrapping
ok_or_return_null_with_table!(result, ERROR_TABLE)
```

**Why**: Predictable, self-documenting, consistent across the API.

### No Hidden Magic

Macros should be simple and transparent:

```rust
// ✅ Good: Clear what it does
#[macro_export]
macro_rules! cstr_or_return_null {
    ($ptr:expr) => {
        match $crate::utils::to_rust_string($ptr) {
            Ok(s) => s,
            Err(e) => {
                e.set_last();
                return std::ptr::null_mut();
            }
        }
    };
}

// ❌ Bad: Too much hidden behavior
// (Theoretical example of what NOT to do)
macro_rules! auto_handle_everything {
    // Does validation, conversion, error handling, logging, metrics...
    // User has no idea what's happening
}
```

## cbindgen Integration

### Document Everything

```rust
/// Creates a new random UUID (version 4).
///
/// # Returns
/// A pointer to a new UUID, or NULL on error.
///
/// # Memory
/// The returned pointer must be freed with `cimpl_free()`.
///
/// # Example
/// ```c
/// Uuid* uuid = uuid_new_v4();
/// if (uuid == NULL) {
///     // Handle error
/// }
/// char* str = uuid_to_string(uuid);
/// printf("%s\n", str);
/// cimpl_free(str);
/// cimpl_free(uuid);
/// ```
#[no_mangle]
pub extern "C" fn uuid_new_v4() -> *mut Uuid {
    box_tracked!(Uuid::new_v4())
}
```

**Why**: These doc comments become Doxygen comments in the C header, helping both humans and AI.

### cbindgen.toml Best Practices

```toml
[export]
include = ["Uuid"]  # Explicitly list types to export

[header]
# Comprehensive documentation including:
# - Error handling conventions
# - Memory management rules
# - Error codes reference
# - Usage examples in C, C++, Python
```

**Put AI hints in the header**:
- Error code constants
- Memory management conventions
- Example code in multiple languages
- Clear documentation of every function

## Testing Strategy

### Test the C API Directly

```c
// test.c - Direct C test
#include "mylib.h"

int main() {
    Uuid* uuid = uuid_new_v4();
    assert(uuid != NULL);
    
    char* str = uuid_to_string(uuid);
    assert(str != NULL);
    printf("%s\n", str);
    
    cimpl_free(str);
    cimpl_free(uuid);
    return 0;
}
```

### Test Language Bindings

Create comprehensive tests for each target language showing:
- Object creation
- Method calls
- Error handling
- Memory management
- Edge cases

## Performance Considerations

### Zero-Cost Abstractions (Mostly)

```rust
// Minimal overhead
#[no_mangle]
pub extern "C" fn uuid_is_nil(uuid: *mut Uuid) -> bool {
    deref_or_return_false!(uuid, Uuid).is_nil()
    // Compiles to: validate pointer → deref → call method
}
```

**Overhead**:
- Pointer validation: ~few nanoseconds (hash lookup)
- Type checking: Compile-time (zero cost)
- Error handling: Only on error path

### When Performance Matters

For hot paths, you can bypass validation:

```rust
// ⚠️ UNSAFE: Caller must guarantee validity
#[no_mangle]
pub unsafe extern "C" fn uuid_is_nil_unchecked(uuid: *mut Uuid) -> bool {
    (*uuid).is_nil()
}
```

But document clearly and prefer safe APIs by default.

## Common Patterns

### Constructor Functions

```rust
#[no_mangle]
pub extern "C" fn thing_new() -> *mut Thing {
    box_tracked!(Thing::new())
}

#[no_mangle]
pub extern "C" fn thing_from_string(s: *const c_char) -> *mut Thing {
    let s_str = cstr_or_return_null!(s);
    let thing = ok_or_return_null_with_table!(
        Thing::from_str(&s_str), 
        THING_ERROR_TABLE
    );
    box_tracked!(thing)
}
```

### Accessor Methods

```rust
// Returns owned string (caller must free)
#[no_mangle]
pub extern "C" fn thing_get_name(ptr: *mut Thing) -> *mut c_char {
    let obj = deref_or_return_null!(ptr, Thing);
    to_c_string(obj.name().to_string())
}

// Returns primitive (no allocation)
#[no_mangle]
pub extern "C" fn thing_get_count(ptr: *mut Thing) -> usize {
    deref_or_return_zero!(ptr, Thing).count()
}
```

### Mutator Methods

```rust
#[no_mangle]
pub extern "C" fn thing_set_name(ptr: *mut Thing, name: *const c_char) -> i32 {
    let obj = deref_mut_or_return_neg!(ptr, Thing);
    let name_str = cstr_or_return_int!(name);
    obj.set_name(name_str);
    0  // Success
}
```

## Debugging Tips

### Enable Allocation Tracking

```rust
// In development
println!("Active allocations: {}", cimpl::get_allocations());
```

### Check Registry State

```rust
// See what's tracked
let registry = cimpl::get_registry();
// Provides information about tracked pointers
```

### Common Issues

1. **Double-free**: `cimpl_free()` returns -1 and sets error
2. **Type mismatch**: Validates `TypeId`, sets `WRONG_HANDLE_TYPE` error
3. **Memory leak**: Check allocation count before/after operations

## Future-Proofing

### API Stability

Once you release a C API, it's hard to change. Design carefully:

- ✅ Return pointers to opaque types (flexible)
- ✅ Separate error checking from operations
- ✅ Use version suffixes for breaking changes (`_v2`)
- ❌ Expose struct internals in C
- ❌ Use platform-specific types in the API

### Versioning

```c
// In header (generated)
#define MYLIB_VERSION_MAJOR 1
#define MYLIB_VERSION_MINOR 0
#define MYLIB_VERSION_PATCH 0

const char* mylib_version(void);
```

## Conclusion

The `cimpl` approach works because:

1. **Rust safety** protects against memory errors
2. **C universality** provides a stable interface
3. **AI generation** creates idiomatic bindings
4. **Standard conventions** make it predictable
5. **Good tooling** (cbindgen, Koffi, ctypes, LuaJIT FFI) handles the heavy lifting

**Remember**: Keep the C API simple and stable. Put complexity in Rust (safe) and idioms in the target language (generated).
