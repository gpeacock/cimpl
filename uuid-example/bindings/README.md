# Language Bindings for cimpl-uuid

This directory contains reference implementations of language bindings for the UUID library, demonstrating what can be generated from the C API.

## Directory Structure

```
bindings/
├── c/              - Reference C example
├── cpp/            - Modern C++ wrapper (RAII, exceptions, smart pointers)
├── python/         - Python ctypes bindings
├── lua/            - LuaJIT FFI bindings
└── (nodejs - removed, see note below)
```

## Purpose

These bindings serve **two purposes**:

1. **Reference Implementations** - They demonstrate the expected quality and structure of bindings that should be generated from the C header file (`include/cimpl_uuid.h`).

2. **Test Suite** - They verify that the C API is correctly exposed and that the `cimpl` patterns work across different FFI technologies.

## Note on JavaScript/Node.js

JavaScript bindings have been **intentionally removed** because **WebAssembly (wasm-bindgen) is the correct approach** for JavaScript/TypeScript, not C FFI. For JavaScript use cases, create WASM bindings directly from Rust rather than going through the C API.

The bindings here demonstrate languages where **C FFI is the appropriate choice**.

## Philosophy: Reference vs. AI-Generated

The bindings here are **maintained reference implementations**. They show what an AI or code generator *should* produce when given the C header file.

For **true AI generation testing**, we recommend:

1. Create an `.ai-generated/` directory (gitignored)
2. Provide an AI model with just the C header
3. Compare the generated output with these references
4. Iterate on the header documentation to improve AI output

## What Makes These "Good" Bindings?

Each binding demonstrates:

- ✅ **Language-idiomatic API** - Not just raw FFI calls
- ✅ **Custom exception/error classes** - Based on C error codes
- ✅ **Automatic memory management** - No manual `free()` calls
- ✅ **Type safety** - Where the language supports it
- ✅ **Documentation** - Docstrings, comments, examples

## Testing All Bindings

From the `uuid-example` root:

```bash
# C
make run-c

# C++
cd bindings/cpp && make run

# Python
cd bindings/python && python3 test.py

# Lua
cd bindings/lua && luajit test.lua
```

## How We Generated These

These bindings were created **manually with AI assistance**, providing:

1. The C header file (`include/cimpl_uuid.h`)
2. A prompt describing the desired API style
3. Iterative refinement of both the C header documentation and the generated code

The goal of `cimpl` is to make the C header so clear and well-documented that step (3) becomes unnecessary.

## Adding More Languages

To add a new language binding:

1. Create `bindings/<language>/`
2. Generate bindings from `include/cimpl_uuid.h`
3. Create a test suite
4. Add a README.md explaining the approach
5. Update this file

Popular candidates:
- **C++** - ✅ Already implemented! (Modern RAII wrapper)
- Ruby (fiddle)
- Go (cgo)
- C# (P/Invoke)
- Swift (C interop)
- Zig (C integration)

## Status

| Language | Status | FFI Technology | Maintained |
|----------|--------|----------------|------------|
| C | ✅ Reference | Native | Yes |
| C++ | ✅ Reference | Native + RAII wrapper | Yes |
| Python | ✅ Reference | ctypes | Yes |
| Lua | ✅ Reference | LuaJIT FFI | Yes |

## The `cimpl` Philosophy

The bindings here demonstrate the **three-stage pipeline**:

1. **Rust** (safe, using `cimpl`) → 
2. **C API** (simple, generated by `cbindgen`) → 
3. **Target Language** (wraps the C API idiomatically)

The C API is the **stable interface**. Language-specific FFI technologies can change, but the C API remains constant.

### Why These Languages?

These bindings demonstrate languages where **C FFI is the correct and idiomatic approach**:

- **C** - Direct use of the C API
- **C++** - Standard practice to wrap C APIs with RAII and exceptions
- **Python** - ctypes/cffi is the standard approach (PyO3 requires owning the Rust code)
- **Lua** - LuaJIT FFI is the standard approach

### What About JavaScript?

For JavaScript/TypeScript, **use wasm-bindgen** to create WASM bindings directly from Rust. This is faster, more portable, and more idiomatic than using C FFI. That's why there's no JavaScript binding here - it would demonstrate the wrong approach.
