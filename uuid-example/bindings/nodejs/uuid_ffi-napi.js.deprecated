/**
 * Node.js FFI bindings for cimpl-uuid library
 * 
 * Auto-generated from cimpl_uuid.h
 */

const ffi = require('ffi-napi');
const ref = require('ref-napi');
const path = require('path');

// Define types
const voidPtr = ref.refType(ref.types.void);
const charPtr = ref.refType(ref.types.char);
const uint8Ptr = ref.refType(ref.types.uint8);

// Error codes (from header)
const ERROR_OK = 0;
const ERROR_NULL_PARAMETER = 1;
const ERROR_STRING_TOO_LONG = 2;
const ERROR_INVALID_HANDLE = 3;
const ERROR_WRONG_HANDLE_TYPE = 4;
const ERROR_OTHER = 5;
const ERROR_UUID_PARSE_ERROR = 100;

// Load the library
const libPath = path.join(__dirname, 'target/release/libcimple_uuid.dylib');
const lib = ffi.Library(libPath, {
  // UUID functions
  'uuid_new_v4': [voidPtr, []],
  'uuid_new_v7': [voidPtr, []],
  'uuid_parse': [voidPtr, [charPtr]],
  'uuid_nil': [voidPtr, []],
  'uuid_max': [voidPtr, []],
  
  'uuid_to_string': [charPtr, [voidPtr]],
  'uuid_to_urn': [charPtr, [voidPtr]],
  'uuid_as_bytes': [uint8Ptr, [voidPtr]],
  
  'uuid_is_nil': ['bool', [voidPtr]],
  'uuid_is_max': ['bool', [voidPtr]],
  
  'uuid_compare': ['int32', [voidPtr, voidPtr]],
  'uuid_equals': ['bool', [voidPtr, voidPtr]],
  
  // Error handling
  'uuid_error_code': ['int32', []],
  'uuid_last_error': [charPtr, []],
  'uuid_clear_error': ['void', []],
  
  // Memory management
  'cimple_free': ['int32', [voidPtr]]
});

// Error classes
class UuidError extends Error {
  constructor(code, message) {
    super(`[${code}] ${message}`);
    this.name = 'UuidError';
    this.code = code;
  }
}

class NullParameterError extends UuidError {
  constructor(message) {
    super(ERROR_NULL_PARAMETER, message);
    this.name = 'NullParameterError';
  }
}

class InvalidHandleError extends UuidError {
  constructor(message) {
    super(ERROR_INVALID_HANDLE, message);
    this.name = 'InvalidHandleError';
  }
}

class WrongHandleTypeError extends UuidError {
  constructor(message) {
    super(ERROR_WRONG_HANDLE_TYPE, message);
    this.name = 'WrongHandleTypeError';
  }
}

class ParseError extends UuidError {
  constructor(message) {
    super(ERROR_UUID_PARSE_ERROR, message);
    this.name = 'ParseError';
  }
}

class OtherError extends UuidError {
  constructor(message) {
    super(ERROR_OTHER, message);
    this.name = 'OtherError';
  }
}

// Map error codes to error classes
const ERROR_CLASSES = {
  [ERROR_NULL_PARAMETER]: NullParameterError,
  [ERROR_INVALID_HANDLE]: InvalidHandleError,
  [ERROR_WRONG_HANDLE_TYPE]: WrongHandleTypeError,
  [ERROR_UUID_PARSE_ERROR]: ParseError,
  [ERROR_OTHER]: OtherError,
};

/**
 * Check for errors and throw appropriate exception
 */
function checkError() {
  const code = lib.uuid_error_code();
  if (code !== ERROR_OK) {
    const msgPtr = lib.uuid_last_error();
    const message = msgPtr.isNull() ? 'Unknown error' : ref.readCString(msgPtr);
    if (!msgPtr.isNull()) {
      lib.cimple_free(msgPtr);
    }
    lib.uuid_clear_error();
    
    const ErrorClass = ERROR_CLASSES[code] || UuidError;
    throw new ErrorClass(message);
  }
}

/**
 * UUID class - JavaScript wrapper for UUID objects
 */
class Uuid {
  constructor(handle) {
    if (!handle || handle.isNull()) {
      checkError();
      throw new Error('Failed to create UUID');
    }
    this._handle = handle;
    this._freed = false;
  }

  /**
   * Generate a random UUID (version 4)
   */
  static v4() {
    return new Uuid(lib.uuid_new_v4());
  }

  /**
   * Generate a timestamp-based UUID (version 7)
   */
  static v7() {
    return new Uuid(lib.uuid_new_v7());
  }

  /**
   * Parse a UUID from a string
   * @throws {ParseError} If the string is not a valid UUID
   */
  static parse(str) {
    const handle = lib.uuid_parse(str);
    if (handle.isNull()) {
      checkError();
    }
    return new Uuid(handle);
  }

  /**
   * Create a nil UUID (all zeros)
   */
  static nil() {
    return new Uuid(lib.uuid_nil());
  }

  /**
   * Create a max UUID (all ones)
   */
  static max() {
    return new Uuid(lib.uuid_max());
  }

  /**
   * Convert UUID to string (hyphenated format)
   */
  toString() {
    if (this._freed) {
      throw new Error('UUID has been freed');
    }
    
    const strPtr = lib.uuid_to_string(this._handle);
    if (strPtr.isNull()) {
      checkError();
    }
    const str = ref.readCString(strPtr);
    lib.cimple_free(strPtr);
    return str;
  }

  /**
   * Convert UUID to URN format
   */
  toUrn() {
    if (this._freed) {
      throw new Error('UUID has been freed');
    }
    
    const urnPtr = lib.uuid_to_urn(this._handle);
    if (urnPtr.isNull()) {
      checkError();
    }
    const urn = ref.readCString(urnPtr);
    lib.cimple_free(urnPtr);
    return urn;
  }

  /**
   * Get UUID as bytes (Buffer of 16 bytes)
   */
  toBytes() {
    if (this._freed) {
      throw new Error('UUID has been freed');
    }
    
    const bytesPtr = lib.uuid_as_bytes(this._handle);
    if (bytesPtr.isNull()) {
      checkError();
    }
    
    // Read 16 bytes
    const buffer = Buffer.alloc(16);
    for (let i = 0; i < 16; i++) {
      buffer[i] = ref.readUInt8(bytesPtr, i);
    }
    
    lib.cimple_free(bytesPtr);
    return buffer;
  }

  /**
   * Check if UUID is nil (all zeros)
   */
  isNil() {
    if (this._freed) {
      throw new Error('UUID has been freed');
    }
    return lib.uuid_is_nil(this._handle);
  }

  /**
   * Check if UUID is max (all ones)
   */
  isMax() {
    if (this._freed) {
      throw new Error('UUID has been freed');
    }
    return lib.uuid_is_max(this._handle);
  }

  /**
   * Compare with another UUID
   * @returns {number} -1 if this < other, 0 if equal, 1 if this > other
   */
  compare(other) {
    if (this._freed || other._freed) {
      throw new Error('UUID has been freed');
    }
    return lib.uuid_compare(this._handle, other._handle);
  }

  /**
   * Check equality with another UUID
   */
  equals(other) {
    if (this._freed || other._freed) {
      throw new Error('UUID has been freed');
    }
    return lib.uuid_equals(this._handle, other._handle);
  }

  /**
   * Free the UUID manually (otherwise happens on GC)
   */
  free() {
    if (!this._freed && this._handle) {
      lib.cimple_free(this._handle);
      this._freed = true;
    }
  }

  /**
   * Get JSON representation
   */
  toJSON() {
    return this.toString();
  }

  /**
   * For console.log()
   */
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `Uuid('${this.toString()}')`;
  }
}

// Export
module.exports = {
  Uuid,
  v4: () => Uuid.v4(),
  v7: () => Uuid.v7(),
  parse: (str) => Uuid.parse(str),
  nil: () => Uuid.nil(),
  max: () => Uuid.max(),
  
  // Error classes
  UuidError,
  NullParameterError,
  InvalidHandleError,
  WrongHandleTypeError,
  ParseError,
  OtherError,
  
  // Error codes
  ERROR_OK,
  ERROR_NULL_PARAMETER,
  ERROR_STRING_TOO_LONG,
  ERROR_INVALID_HANDLE,
  ERROR_WRONG_HANDLE_TYPE,
  ERROR_OTHER,
  ERROR_UUID_PARSE_ERROR,
};
