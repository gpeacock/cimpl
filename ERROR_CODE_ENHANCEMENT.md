# Error Code Enhancement Summary

## What We Added

Enhanced the cimple library with **error codes** to enable language bindings to create typed exceptions, similar to C2paException and C2paError patterns.

## Changes Made

### 1. Core Library (`src/error.rs`)

Added `ErrorCode` enum with integer constants:

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorCode {
    Ok = 0,
    NullParameter = 1,
    StringTooLong = 2,
    InvalidHandle = 3,
    WrongHandleType = 4,
    Other = 5,
}
```

Added methods to `Error`:
- `Error::last_code()` - Get error code from thread-local storage
- `Error::code()` - Get code for a specific error

### 2. Example Library (`example/src/lib.rs`)

**Added Error Constants** (exported to C):
```rust
#[no_mangle]
pub static ERROR_OK: i32 = 0;
#[no_mangle]
pub static ERROR_NULL_PARAMETER: i32 = 1;
// ... etc
```

**Added Error Code Function**:
```rust
#[no_mangle]
pub extern "C" fn mystring_error_code() -> i32 {
    Error::last_code() as i32
}
```

Now libraries expose both:
- `mylib_error_code()` - Get the error type as integer
- `mylib_last_error()` - Get the error message as string

### 3. Generated C Header (`example/include/cimple_example.h`)

The cbindgen-generated header now includes:

**Error Constants:**
```c
extern const int32_t ERROR_OK;
extern const int32_t ERROR_NULL_PARAMETER;
extern const int32_t ERROR_STRING_TOO_LONG;
extern const int32_t ERROR_INVALID_HANDLE;
extern const int32_t ERROR_WRONG_HANDLE_TYPE;
extern const int32_t ERROR_OTHER;
```

**Error Functions:**
```c
int32_t mystring_error_code(void);
char* mystring_last_error(void);
void mystring_clear_error(void);
```

**Complete Documentation** in the header showing:
- How to use error codes in C
- How to create C++ exception classes
- How to create Python exception classes

### 4. Example C Program (`example/example.c`)

Updated to demonstrate error code usage:

```c
void print_error_with_type() {
    int32_t code = mystring_error_code();
    char* error = mystring_last_error();
    if (error != NULL) {
        const char* error_type = "Unknown";
        if (code == ERROR_NULL_PARAMETER) error_type = "NullParameter";
        // ... map code to type name
        fprintf(stderr, "Error [%s] (code %d): %s\n", error_type, code, error);
        mystring_string_free(error);
    }
}
```

### 5. Exception Patterns (`example/PATTERNS.md`)

Added Pattern 11: Complete examples for creating exception wrappers in:
- **C++**: `MyLibException` class
- **Python**: `MyLibError` class with properties
- **Go**: `MyLibError` type

Each shows:
- How to retrieve error code + message
- How to map codes to exception types
- Usage examples

## How AI Can Use This

When given the C header, AI can now:

### 1. Map Error Codes to Exception Types

**C++ Example:**
```cpp
class MyLibException : public std::exception {
    int code_;
    std::string message_;
public:
    MyLibException() : code_(mylib_error_code()) {
        char* msg = mylib_last_error();
        if (msg) {
            message_ = msg;
            mylib_error_free(msg);
        }
    }
    bool is_null_parameter() const { return code_ == ERROR_NULL_PARAMETER; }
};
```

### 2. Create Typed Exception Hierarchies

**Python Example:**
```python
class MyLibError(Exception):
    ERROR_NULL_PARAMETER = 1
    ERROR_INVALID_HANDLE = 3
    
    def __init__(self):
        self.code = lib.mylib_error_code()
        msg_ptr = lib.mylib_last_error()
        self.message = ctypes.c_char_p(msg_ptr).value.decode()
        lib.mylib_error_free(msg_ptr)
    
    @property
    def is_null_parameter(self):
        return self.code == self.ERROR_NULL_PARAMETER
```

### 3. Provide Specific Error Handling

Instead of generic error handling, code can now:
```python
try:
    handle = mylib.create(None)
except MyLibError as e:
    if e.code == MyLibError.ERROR_NULL_PARAMETER:
        # Handle null parameter specifically
        use_default()
    elif e.code == MyLibError.ERROR_INVALID_HANDLE:
        # Handle invalid handle
        recreate_handle()
```

## Benefits

### For Library Authors
âœ… No extra work - just call `Error::last_code()` and export constants
âœ… Standardized pattern across all cimple-based libraries
âœ… Comprehensive documentation auto-generated by cbindgen

### For AI Binding Generators
âœ… Clear integer codes to map to exception types
âœ… Complete examples in header comments
âœ… Consistent pattern to follow (seen in c2pa-c, c2pa-python)

### For End Users
âœ… Type-safe exception handling in their language
âœ… Specific error handling (catch by type, not message parsing)
âœ… Better debugging (error codes + messages)

## Testing

All tests pass:
- âœ… Rust library tests (6 passed)
- âœ… Example library tests (7 passed)
- âœ… C example program (8 tests passed)
- âœ… Error codes correctly exported to header
- âœ… Error constants available from C/C++

## Example Output

```
=== Cimple Example: String Manipulation Library ===

6. Testing error handling with error codes (passing NULL)...
   âœ“ Correctly rejected NULL parameter
   Error [NullParameter] (code 1): NullParameter: new_value

8. Testing double-free protection with error codes...
   âœ“ Double-free correctly detected and prevented
   Error [InvalidHandle] (code 3): InvalidHandle: 1
```

## Files Modified

1. `src/error.rs` - Added ErrorCode enum and methods
2. `src/lib.rs` - Exported ErrorCode
3. `example/src/lib.rs` - Added error code function and constants
4. `example/cbindgen.toml` - Enhanced with error handling documentation
5. `example/example.c` - Demonstrate error code usage
6. `example/PATTERNS.md` - Added exception wrapper patterns

## Next Steps

Library authors using cimple can now:
1. Export `mylib_error_code()` function
2. Export `ERROR_*` constants
3. Document in header with examples
4. AI will automatically create proper exception classes!

This matches the pattern you're already using in c2pa-c and c2pa-python! ðŸŽ‰
