# Quick Start Guide

## Build and Run in 30 Seconds

```bash
# From the example directory
make run-c
```

That's it! This will:
1. Build the Rust library (static + dynamic)
2. Generate the C header
3. Compile the C example
4. Run it

## What Just Happened?

### Stage 1: Rust → C Library
The Rust code in `src/lib.rs` was compiled into:
- `target/release/libcimpl_example.a` (static library)
- `target/release/libcimpl_example.dylib` (dynamic library)

### Stage 2: Auto-Generated C Header
`cbindgen` extracted all the C API documentation and generated:
- `include/cimpl_example.h`

Look at this header - it's clean, well-documented C that any tool can understand!

### Stage 3: C Program Uses It
The `example.c` program demonstrates all features:
- Creating/freeing handles
- Getting/setting values
- String operations
- Error handling
- Memory safety

## Try It Yourself

### 1. Look at the Generated Header

```bash
cat include/cimpl_example.h
```

Notice:
- Clean C types (no Rust leaking through!)
- Full Doxygen documentation
- Simple, predictable API

### 2. Modify the Example

Edit `example.c` to experiment:

```c
MyStringHandle* handle = mystring_create("Your text here!");
char* result = mystring_to_uppercase(handle);
printf("%s\n", result);
mystring_string_free(result);
mystring_free(handle);
```

Rebuild and run:
```bash
make run-c
```

### 3. Test Memory Safety

Try causing errors to see the safety features:

```c
// Double-free detection
mystring_free(handle);
mystring_free(handle);  // Returns -1, prints warning

// NULL parameter handling  
mystring_set_value(NULL, "test");  // Returns -1, sets error
char* error = mystring_last_error();
printf("%s\n", error);
mystring_string_free(error);
```

## Next: Language Bindings with AI

Now give the header to an AI to generate bindings for your language:

### Python Example

```
"Create Python ctypes bindings for this C library:

[paste include/cimpl_example.h contents]

The library files are:
- Linux: libcimpl_example.so
- macOS: libcimpl_example.dylib  
- Windows: cimpl_example.dll"
```

The AI will generate idiomatic Python like:

```python
class MyString:
    def __init__(self, initial: str):
        self._handle = lib.mystring_create(initial.encode())
    
    def to_uppercase(self) -> str:
        result = lib.mystring_to_uppercase(self._handle)
        value = result.decode()
        lib.mystring_string_free(result)
        return value
    
    def __del__(self):
        lib.mystring_free(self._handle)
```

### Node.js Example

```
"Create Node.js N-API bindings for this C library:

[paste include/cimpl_example.h]"
```

The AI will create:

```javascript
class MyString {
    constructor(initial) {
        this.handle = native.mystring_create(initial);
    }
    
    toUppercase() {
        return native.mystring_to_uppercase(this.handle);
    }
    
    free() {
        native.mystring_free(this.handle);
    }
}
```

## Make Targets

```bash
make build           # Build Rust library + generate header
make test            # Run Rust tests
make example         # Build C example (static linking)
make example-dynamic # Build C example (dynamic linking)
make run-c           # Build and run (static)
make run-c-dynamic   # Build and run (dynamic)
make clean           # Remove all build artifacts
make help            # Show all targets
```

## File Structure

```
example/
├── src/lib.rs              # Rust implementation with C FFI
├── include/                # Generated by cbindgen
│   └── cimpl_example.h    # C header (give this to AI!)
├── target/release/         # Build outputs
│   ├── libcimpl_example.a     # Static library
│   └── libcimpl_example.dylib # Dynamic library
├── example.c               # C example program
├── Cargo.toml              # Rust package config
├── build.rs                # Runs cbindgen at build time
├── cbindgen.toml           # Header generation config
└── Makefile                # Convenience commands
```

## Common Issues

### Issue: "library not found"
**Solution**: Use static linking (default) or set library path:
```bash
export LD_LIBRARY_PATH=target/release:$LD_LIBRARY_PATH  # Linux
export DYLD_LIBRARY_PATH=target/release:$DYLD_LIBRARY_PATH  # macOS
```

### Issue: "undefined reference"
**Solution**: Make sure you're linking all required libraries:
```bash
gcc example.c -o example \
    -Iinclude \
    target/release/libcimpl_example.a \
    -lpthread -ldl -lm
```

### Issue: "header not found"
**Solution**: Run `cargo build` first to generate the header:
```bash
cargo build --release
```

## What Makes This AI-Friendly?

1. **Simple C types**: No complex Rust types leak through
2. **Opaque handles**: Pointers that hide Rust complexity
3. **Consistent patterns**: Same error handling everywhere
4. **Self-documenting**: Header has everything AI needs
5. **Predictable memory**: Clear ownership rules

The AI doesn't need to understand Rust - just read the C header!
