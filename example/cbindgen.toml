# cbindgen configuration for generating C headers
#
# This configuration generates comprehensive C headers with embedded documentation
# that helps both human developers and AI code generators create language bindings.
#
# Key principles:
# 1. Document error handling conventions (standard C: NULL/-1 = error)
# 2. Provide error code constants that map to exception classes
# 3. Include complete examples in multiple languages (C, C++, Python)
# 4. Explain memory management rules (cimpl_free for all allocations)
# 5. Make the header self-documenting for AI binding generation
#
# See DESIGN_GUIDE.md and LANGUAGE_BINDINGS.md for complete documentation.

language = "C"
include_guard = "CIMPL_EXAMPLE_H"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
documentation = true
documentation_style = "doxy"
line_length = 100
tab_width = 4
cpp_compat = true

# Add comprehensive header documentation about error handling
header = """
/* Generated by cbindgen - DO NOT EDIT MANUALLY */

/**
 * @file cimpl_example.h
 * @brief Example library demonstrating cimpl FFI patterns
 * 
 * @section error_convention Error Convention (Standard C Pattern)
 * 
 * This library follows standard C error conventions similar to errno.
 * 
 * **Return values indicate success or failure:**
 * - Pointer-returning functions: Return NULL on error
 * - Integer-returning functions: Return -1 on error, 0 on success
 * - Some functions never error (documented per-function)
 * 
 * **Error details are retrieved conditionally:**
 * Only check error code/message AFTER a function indicates failure.
 * 
 * @subsection error_functions Error Retrieval Functions
 * 
 * - mystring_error_code() - Get error type as integer (0 = no error)
 * - mystring_last_error() - Get error message string (must free with mystring_string_free)
 * - mystring_clear_error() - Clear the error state
 * 
 * @subsection error_codes Error Codes
 * 
 * The library defines the following error codes:
 * - 0: ERROR_OK - No error
 * - 1: ERROR_NULL_PARAMETER - A required parameter was NULL
 * - 2: ERROR_STRING_TOO_LONG - String exceeds maximum length
 * - 3: ERROR_INVALID_HANDLE - Handle is invalid or already freed
 * - 4: ERROR_WRONG_HANDLE_TYPE - Handle type doesn't match expected type
 * - 5: ERROR_OTHER - Other error occurred
 * - 1000+: Reserved for user library custom errors
 * 
 * @note Error messages include the error type name, e.g., "NullParameter: value"
 * 
 * @subsection error_example_c Error Handling Example (C)
 * 
 * @code{.c}
 * // Constructor returns NULL on error
 * MyStringHandle* handle = mystring_create("test");
 * if (handle == NULL) {
 *     // NOW check error details
 *     int32_t code = mystring_error_code();
 *     char* msg = mystring_last_error();
 *     fprintf(stderr, "Error %d: %s\n", code, msg);
 *     mystring_string_free(msg);
 *     return -1;
 * }
 * 
 * // Operation returns -1 on error
 * if (mystring_set_value(handle, "new") != 0) {
 *     // NOW check error details
 *     fprintf(stderr, "Error: %s\n", mystring_last_error());
 * }
 * @endcode
 * 
 * @subsection error_example_cpp Creating C++ Exceptions
 * 
 * @code{.cpp}
 * class MyStringException : public std::exception {
 *     int code_;
 *     std::string message_;
 * public:
 *     MyStringException() : code_(mystring_error_code()) {
 *         char* msg = mystring_last_error();
 *         if (msg) {
 *             message_ = msg;  // Already formatted: "ErrorType: details"
 *             mystring_string_free(msg);
 *         }
 *     }
 *     const char* what() const noexcept override { return message_.c_str(); }
 *     int code() const { return code_; }
 * };
 * 
 * // Usage with automatic exception on error:
 * MyStringHandle* handle = mystring_create("test");
 * if (handle == nullptr) {
 *     throw MyStringException();
 * }
 * @endcode
 * 
 * @subsection error_example_python Creating Python Exceptions
 * 
 * @code{.py}
 * class MyStringError(Exception):
 *     def __init__(self):
 *         self.code = lib.mystring_error_code()
 *         msg_ptr = lib.mystring_last_error()
 *         if msg_ptr:
 *             self.message = ctypes.c_char_p(msg_ptr).value.decode()
 *             lib.mystring_string_free(msg_ptr)
 *         else:
 *             self.message = "Unknown error"
 *     
 *     def __str__(self):
 *         return f"[{self.code}] {self.message}"
 * 
 * # Usage with automatic exception on error:
 * handle = lib.mystring_create(b"test")
 * if not handle:
 *     raise MyStringError()
 * @endcode
 * 
 * @section memory_management Memory Management
 * 
 * - Handles created with *_create() must be freed with *_free()
 * - Strings returned by functions must be freed with mystring_string_free()
 * - Passing NULL to free functions is safe and will return success
 * - Double-free attempts are detected and return an error
 */
"""

# Add cimpl_free declaration manually since it's from the parent crate
after_includes = """
/**
 * @brief Universal free function for any pointer allocated by this library
 *
 * This function can free ANY pointer allocated and returned by functions in this
 * library, including:
 * - MyString objects (returned by mystring_create)
 * - Strings (returned by mystring_get_value, mystring_to_uppercase, etc.)
 * - Any other tracked pointers
 *
 * @param ptr Pointer to free (can be NULL)
 * @return 0 on success, -1 on error (invalid pointer or double-free)
 *
 * @note Safe to call with NULL (returns 0)
 * @note Safe to call with any tracked pointer
 * @warning DO NOT call on pointers you allocated yourself from C
 * @warning Calling twice on the same pointer returns -1 (double-free protection)
 *
 * @par Example:
 * @code
 * MyString* str = mystring_create("hello");
 * char* value = mystring_get_value(str);
 * 
 * cimpl_free(value);  // Free the string
 * cimpl_free(str);    // Free the MyString
 * @endcode
 */
int32_t cimpl_free(void *ptr);
"""

[export]
# Only export items explicitly marked with #[no_mangle] and pub extern "C"
include = ["MyString", "ErrorCode"]

[enum]
# Make error codes use standard C naming
rename_variants = "ScreamingSnakeCase"
prefix_with_name = true

[fn]
# Function name style
rename_args = "CamelCase"

[parse]
parse_deps = false
include = ["cimpl"]
